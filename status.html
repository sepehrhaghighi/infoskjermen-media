<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Status & Timing Control</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; padding:0; background:#0b0b0b; color:#f2f2f2; font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 980px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .muted { color:#bdbdbd; }
    .card { background:#151515; border:1px solid #242424; border-radius: 14px; padding: 14px; margin: 12px 0; }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items:center; }
    label { display:flex; gap:8px; align-items:center; }
    input[type="number"], input[type="password"] {
      width: 140px; padding: 6px 8px; border-radius: 10px; border:1px solid #2b2b2b; background:#0f0f0f; color:#fff;
    }
    input[type="password"] { width: 220px; }
    button { padding: 8px 10px; border-radius: 10px; border:1px solid #2b2b2b; background:#0f0f0f; color:#fff; cursor:pointer; }
    button:hover { background:#141414; }
    table { width:100%; border-collapse: collapse; }
    th, td { text-align:left; padding: 10px 8px; border-bottom: 1px solid #242424; vertical-align: top; }
    th { color:#cfcfcf; font-weight:600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .right { text-align:right; }
    a { color:#9dd1ff; text-decoration:none; }
    a:hover { text-decoration:underline; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; border:1px solid #2b2b2b; background:#0f0f0f; color:#eaeaea; font-size: 12px; }
    .ok { border-color:#2e5; color:#bfffd0; }
    .bad { border-color:#e55; color:#ffd0d0; }
    .small { font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Status & timing control</h1>

    <div class="card">
      <div class="row">
        <label>Seconds per poster
          <!-- IMPORTANT: no baked-in "value=12" so it won't visually snap back on reload -->
          <input id="posterSeconds" type="number" min="1" placeholder="12">
        </label>
        <label>Fade (ms)
          <input id="fadeMs" type="number" min="0" placeholder="900">
        </label>
        <label>Refresh (sec)
          <input id="refreshSeconds" type="number" min="30" placeholder="300">
        </label>
      </div>

      <div class="row" style="margin-top:10px;">
        <label>Update key
          <input id="updateKey" type="password" placeholder="(required)">
        </label>
        <button id="applyBtn">Apply</button>
        <span id="info" class="muted small"></span>
      </div>

      <div class="muted small" style="margin-top:10px;">
        Apply updates the shared config in Drive. All slideshow pages pick it up automatically.
      </div>
    </div>

    <div class="card">
      <div class="muted small" style="margin-bottom:10px;">
        Counts are based on <span class="mono">assets/films.json</span> and <span class="mono">assets/arrangements.json</span>.
        Suggested duration = count × seconds-per-poster.
      </div>

      <table>
        <thead>
          <tr>
            <th>Page</th>
            <th>What it shows</th>
            <th class="right">Count</th>
            <th class="right">Suggested duration</th>
          </tr>
        </thead>
        <tbody id="tbody">
          <tr><td colspan="4" class="muted">Loading…</td></tr>
        </tbody>
      </table>
    </div>

    <div class="card">
      <div class="row" style="gap:10px;">
        <a href="./films-portrait.html" target="_blank">films-portrait</a>
        <a href="./films-landscape.html" target="_blank">films-landscape</a>
        <a href="./arrangements-portrait.html" target="_blank">arrangements-portrait</a>
        <a href="./arrangements-landscape.html" target="_blank">arrangements-landscape</a>
        <a href="./portrait-all.html" target="_blank">portrait-all</a>
        <a href="./landscape-all.html" target="_blank">landscape-all</a>
      </div>
    </div>
  </div>

<script>
(() => {
  const CONFIG_SERVICE_URL = "https://script.google.com/macros/s/AKfycbzfSFnMeg-26QNv802KVleuZWoEPqQE8zU4JwQLO3ikWL-fpYP4SFWTu8Q89jmgXq0YvQ/exec";
  const FILMS_URL = "./assets/films.json";
  const ARR_URL   = "./assets/arrangements.json";

  const DEFAULTS = {
    posterSeconds: 12,
    fadeMs: 900,
    manifestRefreshSeconds: 300,
  };

  const els = {
    posterSeconds: document.getElementById("posterSeconds"),
    fadeMs: document.getElementById("fadeMs"),
    refreshSeconds: document.getElementById("refreshSeconds"),
    updateKey: document.getElementById("updateKey"),
    applyBtn: document.getElementById("applyBtn"),
    tbody: document.getElementById("tbody"),
    info: document.getElementById("info"),
  };

  function pill(text, cls="ok") {
    return `<span class="pill ${cls}">${text}</span>`;
  }

  function fmtDuration(seconds) {
    seconds = Math.max(0, Math.round(seconds));
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${m}:${String(s).padStart(2,'0')}`;
  }

  async function fetchJson(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`${r.status} ${r.statusText} for ${url}`);
    return await r.json();
  }

  // JSONP config loader (avoids CORS issues)
  function loadConfigJSONP(timeoutMs = 5000) {
    return new Promise((resolve) => {
      const cbName = "__cfgcb_" + Math.random().toString(16).slice(2);
      let done = false;

      window[cbName] = (cfg) => {
        done = true;
        cleanup();
        resolve(cfg || {});
      };

      const s = document.createElement("script");
      s.src = CONFIG_SERVICE_URL + "?callback=" + cbName + "&_=" + Date.now();
      s.onerror = () => { cleanup(); resolve({}); };
      document.head.appendChild(s);

      const t = setTimeout(() => { if (!done) { cleanup(); resolve({}); } }, timeoutMs);

      function cleanup() {
        clearTimeout(t);
        try { delete window[cbName]; } catch {}
        s.remove();
      }
    });
  }

  function setInfo(msg) {
    els.info.textContent = msg || "";
  }

  function safeNumber(x) {
    const n = Number(x);
    return Number.isFinite(n) ? n : null;
  }

  // Normalize whatever Apps Script returns into our expected config shape.
  function normalizeCfg(raw) {
    if (!raw) return {};
    if (typeof raw === "string") {
      try { return JSON.parse(raw); } catch { return {}; }
    }
    // common pattern: { data: {...} }
    if (raw.data && typeof raw.data === "object") return raw.data;
    return raw;
  }

  // Read config from UI, but do NOT fall back to defaults silently; we control defaults elsewhere.
  function readUiConfig() {
    const ps = safeNumber(els.posterSeconds.value);
    const fm = safeNumber(els.fadeMs.value);
    const rs = safeNumber(els.refreshSeconds.value);

    return {
      posterSeconds: ps ?? DEFAULTS.posterSeconds,
      fadeMs: fm ?? DEFAULTS.fadeMs,
      manifestRefreshSeconds: rs ?? DEFAULTS.manifestRefreshSeconds,
    };
  }

  // IMPORTANT: only apply values that actually exist in loaded config.
  // If config load fails / returns empty, we KEEP current UI values (no snap-back).
  function setUiConfig(rawCfg) {
    const cfg = normalizeCfg(rawCfg);

    const refresh = cfg.manifestRefreshSeconds ?? cfg.refreshSeconds;

    const hasAny =
      cfg.posterSeconds != null ||
      cfg.fadeMs != null ||
      refresh != null;

    if (!hasAny) {
      // Do not overwrite UI with defaults; keep what's currently shown.
      setInfo("Couldn’t load saved config (showing current values).");
      return false;
    }

    if (cfg.posterSeconds != null) els.posterSeconds.value = cfg.posterSeconds;
    if (cfg.fadeMs != null) els.fadeMs.value = cfg.fadeMs;
    if (refresh != null) els.refreshSeconds.value = refresh;

    return true;
  }

  function countField(items, field) {
    return (items || []).map(x => x?.[field]).filter(Boolean).length;
  }

  async function renderCounts() {
    const posterSeconds = safeNumber(els.posterSeconds.value) ?? DEFAULTS.posterSeconds;
    els.tbody.innerHTML = `<tr><td colspan="4" class="muted">Loading…</td></tr>`;

    try {
      const [filmsData, arrData] = await Promise.all([fetchJson(FILMS_URL), fetchJson(ARR_URL)]);
      const films = filmsData.films || [];
      const arrs  = arrData.arrangements || [];

      const filmsPortrait = countField(films, "poster");
      const filmsLandscape= countField(films, "landscape");
      const arrPortrait   = countField(arrs, "poster");
      const arrLandscape  = countField(arrs, "landscape");

      const portraitAll = filmsPortrait + arrPortrait;
      const landscapeAll= filmsLandscape + arrLandscape;

      const rows = [
        { page:"films-portrait.html", desc:"Films portrait (poster)", count: filmsPortrait },
        { page:"films-landscape.html", desc:"Films landscape (subset)", count: filmsLandscape },
        { page:"arrangements-portrait.html", desc:"Arrangements portrait (poster)", count: arrPortrait },
        { page:"arrangements-landscape.html", desc:"Arrangements landscape (subset)", count: arrLandscape },
        { page:"portrait-all.html", desc:"Films then arrangements (portrait)", count: portraitAll },
        { page:"landscape-all.html", desc:"Films then arrangements (landscape subset)", count: landscapeAll }
      ];

      els.tbody.innerHTML = rows.map(r => `
        <tr>
          <td>${pill("ok","ok")} <a href="./${r.page}" target="_blank">${r.page}</a></td>
          <td class="muted">${r.desc}</td>
          <td class="right mono">${r.count}</td>
          <td class="right mono">${fmtDuration(r.count * posterSeconds)}</td>
        </tr>
      `).join("");

      const u1 = filmsData.updated ? `films: ${filmsData.updated}` : `films: (no updated)`;
      const u2 = arrData.updated ? `arr: ${arrData.updated}` : `arr: (no updated)`;
      // only set info if we don't already have an important status message
      if (!els.info.textContent || els.info.textContent.startsWith("films:") || els.info.textContent.startsWith("arr:")) {
        els.info.textContent = `${u1} | ${u2}`;
      }
    } catch (e) {
      els.tbody.innerHTML = `<tr><td colspan="4">${pill("ERROR","bad")} <span class="mono">${String(e.message || e)}</span></td></tr>`;
    }
  }

  async function reloadConfig() {
    const cfg = await loadConfigJSONP();
    return setUiConfig(cfg);
  }

  async function applyConfig() {
    const key = (els.updateKey.value || "").trim();
    if (!key) {
      setInfo("Update key is required.");
      return;
    }

    // store key on this device for convenience
    try { localStorage.setItem("poster_update_key", key); } catch {}

    const cfg = readUiConfig();
    const body = new URLSearchParams({
      posterSeconds: String(cfg.posterSeconds),
      fadeMs: String(cfg.fadeMs),
      manifestRefreshSeconds: String(cfg.manifestRefreshSeconds),
    }).toString();

    const url = CONFIG_SERVICE_URL + "?key=" + encodeURIComponent(key);

    setInfo("Applying…");

    try {
      // Apps Script POST + no-cors means we can't read the response, but request is sent.
      await fetch(url, {
        method: "POST",
        mode: "no-cors",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body
      });

      // auto-reload config + counts so operator never needs another button
      setTimeout(async () => {
        try {
          const ok = await reloadConfig();
          await renderCounts();
          setInfo(ok ? "Applied ✓" : "Applied ✓ (saved, but reload returned empty)");
        } catch {
          setInfo("Applied ✓ (reload failed)");
        }
      }, 1200);

    } catch (e) {
      setInfo("Apply failed: " + String(e.message || e));
    }
  }

  els.applyBtn.addEventListener("click", applyConfig);

  (async () => {
    // show initial defaults immediately (optional but nice UX)
    els.posterSeconds.value = DEFAULTS.posterSeconds;
    els.fadeMs.value = DEFAULTS.fadeMs;
    els.refreshSeconds.value = DEFAULTS.manifestRefreshSeconds;

    // prefill key on this device if present
    try {
      const k = localStorage.getItem("poster_update_key");
      if (k) els.updateKey.value = k;
    } catch {}

    await reloadConfig();   // will NOT overwrite UI if load fails
    await renderCounts();
  })();
})();
</script>
</body>
</html>