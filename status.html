<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Status & Timing Control</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; padding:0; background:#0b0b0b; color:#f2f2f2; font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 980px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .muted { color:#bdbdbd; }
    .card { background:#151515; border:1px solid #242424; border-radius: 14px; padding: 14px; margin: 12px 0; }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items:center; }
    label { display:flex; gap:8px; align-items:center; }
    input[type="number"], input[type="password"] {
      width: 140px; padding: 6px 8px; border-radius: 10px; border:1px solid #2b2b2b; background:#0f0f0f; color:#fff;
    }
    input[type="password"] { width: 220px; }
    button { padding: 8px 10px; border-radius: 10px; border:1px solid #2b2b2b; background:#0f0f0f; color:#fff; cursor:pointer; }
    button:hover { background:#141414; }
    table { width:100%; border-collapse: collapse; }
    th, td { text-align:left; padding: 10px 8px; border-bottom: 1px solid #242424; vertical-align: top; }
    th { color:#cfcfcf; font-weight:600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .right { text-align:right; }
    a { color:#9dd1ff; text-decoration:none; }
    a:hover { text-decoration:underline; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; border:1px solid #2b2b2b; background:#0f0f0f; color:#eaeaea; font-size: 12px; }
    .ok { border-color:#2e5; color:#bfffd0; }
    .bad { border-color:#e55; color:#ffd0d0; }
    .small { font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Status & timing control</h1>

    <div class="card">
      <div class="row">
        <label>Seconds per poster
          <input id="posterSeconds" type="number" min="1" placeholder="12">
        </label>
        <label>Fade (ms)
          <input id="fadeMs" type="number" min="0" placeholder="900">
        </label>
        <label>Refresh (sec)
          <input id="refreshSeconds" type="number" min="30" placeholder="300">
        </label>
      </div>

      <div class="row" style="margin-top:10px;">
        <label>Update key
          <input id="updateKey" type="password" placeholder="(required)">
        </label>
        <button id="applyBtn">Apply</button>
        <span id="info" class="muted small"></span>
      </div>

      <div class="muted small" style="margin-top:10px;">
        Apply updates the shared config in Drive. All slideshow pages pick it up automatically.
      </div>
    </div>

    <div class="card">
      <div class="muted small" style="margin-bottom:10px;">
        Counts are based on <span class="mono">assets/films.json</span> and <span class="mono">assets/arrangements.json</span>.
        Suggested duration = count × seconds-per-poster.
      </div>

      <table>
        <thead>
          <tr>
            <th>Page</th>
            <th>What it shows</th>
            <th class="right">Count</th>
            <th class="right">Suggested duration</th>
          </tr>
        </thead>
        <tbody id="tbody">
          <tr><td colspan="4" class="muted">Loading…</td></tr>
        </tbody>
      </table>
    </div>

    <div class="card">
      <div class="row" style="gap:10px;">
        <a href="./films-portrait.html" target="_blank">films-portrait</a>
        <a href="./films-landscape.html" target="_blank">films-landscape</a>
        <a href="./arrangements-portrait.html" target="_blank">arrangements-portrait</a>
        <a href="./arrangements-landscape.html" target="_blank">arrangements-landscape</a>
        <a href="./portrait-all.html" target="_blank">portrait-all</a>
        <a href="./landscape-all.html" target="_blank">landscape-all</a>
      </div>
    </div>
  </div>

<script>
(() => {
  const CONFIG_SERVICE_URL = "https://script.google.com/macros/s/AKfycbzfSFnMeg-26QNv802KVleuZWoEPqQE8zU4JwQLO3ikWL-fpYP4SFWTu8Q89jmgXq0YvQ/exec";
  const FILMS_URL = "./assets/films.json";
  const ARR_URL   = "./assets/arrangements.json";

  const DEFAULTS = { posterSeconds: 12, fadeMs: 900, manifestRefreshSeconds: 300 };

  const els = {
    posterSeconds: document.getElementById("posterSeconds"),
    fadeMs: document.getElementById("fadeMs"),
    refreshSeconds: document.getElementById("refreshSeconds"),
    updateKey: document.getElementById("updateKey"),
    applyBtn: document.getElementById("applyBtn"),
    tbody: document.getElementById("tbody"),
    info: document.getElementById("info"),
  };

  const setInfo = (msg) => { els.info.textContent = msg || ""; };

  function pill(text, cls="ok") { return `<span class="pill ${cls}">${text}</span>`; }

  function fmtDuration(seconds) {
    seconds = Math.max(0, Math.round(seconds));
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${m}:${String(s).padStart(2,'0')}`;
  }

  async function fetchJson(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`${r.status} ${r.statusText} for ${url}`);
    return await r.json();
  }

  function safeNumber(x) {
    const n = Number(x);
    return Number.isFinite(n) ? n : null;
  }

  function normalizeCfg(raw) {
    if (!raw) return {};
    if (typeof raw === "string") { try { return JSON.parse(raw); } catch { return {}; } }
    if (raw.data && typeof raw.data === "object") return raw.data;
    if (raw.config && typeof raw.config === "object") return raw.config;
    return raw;
  }

  function isMeaningfulCfg(raw) {
    const cfg = normalizeCfg(raw);
    const refresh = cfg.manifestRefreshSeconds ?? cfg.refreshSeconds;
    return (cfg.posterSeconds != null) || (cfg.fadeMs != null) || (refresh != null);
  }

  // JSONP loader (avoids CORS issues). Also detects "HTML/login page" cases.
  function loadConfigJSONP(extraParams = {}, timeoutMs = 7000) {
    return new Promise((resolve) => {
      const cbName = "__cfgcb_" + Math.random().toString(16).slice(2);
      let called = false;
      let finished = false;

      window[cbName] = (cfg) => {
        called = true;
        finish(cfg || {});
      };

      const params = new URLSearchParams({
        callback: cbName,
        _: String(Date.now()),
        ...Object.fromEntries(Object.entries(extraParams).filter(([,v]) => v != null && String(v).length > 0))
      });

      const s = document.createElement("script");
      s.src = CONFIG_SERVICE_URL + "?" + params.toString();

      s.onerror = () => {
        setInfo("Config read failed (script error). Check Apps Script is public + returns JSONP.");
        finish({});
      };

      s.onload = () => {
        setTimeout(() => {
          if (!finished && !called) {
            setInfo("Config endpoint did not call JSONP callback (likely not public or not JSONP).");
            finish({});
          }
        }, 250);
      };

      document.head.appendChild(s);

      const t = setTimeout(() => {
        if (!finished) {
          setInfo("Config read timed out. Check Apps Script access/public deployment.");
          finish({});
        }
      }, timeoutMs);

      function cleanup() {
        clearTimeout(t);
        try { delete window[cbName]; } catch {}
        s.remove();
      }

      function finish(val) {
        if (finished) return;
        finished = true;
        cleanup();
        resolve(val);
      }
    });
  }

  function setUiConfig(rawCfg) {
    const cfg = normalizeCfg(rawCfg);
    const refresh = cfg.manifestRefreshSeconds ?? cfg.refreshSeconds;

    // Only touch fields that exist (never snap-back due to empty load)
    if (cfg.posterSeconds != null) els.posterSeconds.value = cfg.posterSeconds;
    if (cfg.fadeMs != null) els.fadeMs.value = cfg.fadeMs;
    if (refresh != null) els.refreshSeconds.value = refresh;
  }

  function readUiConfig() {
    return {
      posterSeconds: safeNumber(els.posterSeconds.value) ?? DEFAULTS.posterSeconds,
      fadeMs: safeNumber(els.fadeMs.value) ?? DEFAULTS.fadeMs,
      manifestRefreshSeconds: safeNumber(els.refreshSeconds.value) ?? DEFAULTS.manifestRefreshSeconds,
    };
  }

  function countField(items, field) {
    return (items || []).map(x => x?.[field]).filter(Boolean).length;
  }

  async function renderCounts() {
    const posterSeconds = safeNumber(els.posterSeconds.value) ?? DEFAULTS.posterSeconds;
    els.tbody.innerHTML = `<tr><td colspan="4" class="muted">Loading…</td></tr>`;

    try {
      const [filmsData, arrData] = await Promise.all([fetchJson(FILMS_URL), fetchJson(ARR_URL)]);
      const films = filmsData.films || [];
      const arrs  = arrData.arrangements || [];

      const filmsPortrait = countField(films, "poster");
      const filmsLandscape= countField(films, "landscape");
      const arrPortrait   = countField(arrs, "poster");
      const arrLandscape  = countField(arrs, "landscape");

      const portraitAll = filmsPortrait + arrPortrait;
      const landscapeAll= filmsLandscape + arrLandscape;

      const rows = [
        { page:"films-portrait.html", desc:"Films portrait (poster)", count: filmsPortrait },
        { page:"films-landscape.html", desc:"Films landscape (subset)", count: filmsLandscape },
        { page:"arrangements-portrait.html", desc:"Arrangements portrait (poster)", count: arrPortrait },
        { page:"arrangements-landscape.html", desc:"Arrangements landscape (subset)", count: arrLandscape },
        { page:"portrait-all.html", desc:"Films then arrangements (portrait)", count: portraitAll },
        { page:"landscape-all.html", desc:"Films then arrangements (landscape subset)", count: landscapeAll }
      ];

      els.tbody.innerHTML = rows.map(r => `
        <tr>
          <td>${pill("ok","ok")} <a href="./${r.page}" target="_blank">${r.page}</a></td>
          <td class="muted">${r.desc}</td>
          <td class="right mono">${r.count}</td>
          <td class="right mono">${fmtDuration(r.count * posterSeconds)}</td>
        </tr>
      `).join("");

      const u1 = filmsData.updated ? `films: ${filmsData.updated}` : `films: (no updated)`;
      const u2 = arrData.updated ? `arr: ${arrData.updated}` : `arr: (no updated)`;
      if (!els.info.textContent || els.info.textContent.startsWith("films:") || els.info.textContent.startsWith("arr:")) {
        els.info.textContent = `${u1} | ${u2}`;
      }
    } catch (e) {
      els.tbody.innerHTML = `<tr><td colspan="4">${pill("ERROR","bad")} <span class="mono">${String(e.message || e)}</span></td></tr>`;
    }
  }

  async function reloadConfig() {
    // 1) try public read
    let cfg = await loadConfigJSONP({});
    if (isMeaningfulCfg(cfg)) {
      setUiConfig(cfg);
      return true;
    }

    // 2) fallback: try read with key (in case Apps Script requires key for GET too)
    const key = (els.updateKey.value || "").trim();
    if (key) {
      const cfg2 = await loadConfigJSONP({ key });
      if (isMeaningfulCfg(cfg2)) {
        setUiConfig(cfg2);
        return true;
      }
    }
    return false;
  }

  async function applyConfig() {
    const key = (els.updateKey.value || "").trim();
    if (!key) { setInfo("Update key is required."); return; }

    const cfg = readUiConfig();
    const body = new URLSearchParams({
      posterSeconds: String(cfg.posterSeconds),
      fadeMs: String(cfg.fadeMs),
      manifestRefreshSeconds: String(cfg.manifestRefreshSeconds),
    }).toString();

    const url = CONFIG_SERVICE_URL + "?key=" + encodeURIComponent(key);

    setInfo("Applying…");

    try {
      await fetch(url, {
        method: "POST",
        mode: "no-cors",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body
      });

      setTimeout(async () => {
        const ok = await reloadConfig();
        await renderCounts();
        setInfo(ok ? "Applied ✓" : "Applied ✓ (saved, but reload returned empty)");
      }, 1200);

    } catch (e) {
      setInfo("Apply failed: " + String(e.message || e));
    }
  }

  els.applyBtn.addEventListener("click", applyConfig);

  // Always clear password on reload/navigation away (and never store it)
  window.addEventListener("beforeunload", () => { els.updateKey.value = ""; });

  (async () => {
    // show defaults immediately
    els.posterSeconds.value = DEFAULTS.posterSeconds;
    els.fadeMs.value = DEFAULTS.fadeMs;
    els.refreshSeconds.value = DEFAULTS.manifestRefreshSeconds;

    // IMPORTANT: always clear key on load, and delete any old stored key
    els.updateKey.value = "";
    try { localStorage.removeItem("poster_update_key"); } catch {}

    await reloadConfig();
    await renderCounts();
  })();
})();
</script>
</body>
</html>
