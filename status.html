<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Status & Timing Control</title>
  <style>
    :root {
      color-scheme: dark;

      /* ✅ CHANGE THIS to your image path or a full URL */
      --bg-url: url("./assets/status-bg.jpg");

      /* tweak darkness/blur if you want */
      --bg-dim: 0.78;     /* 0..1 (higher = darker overlay) */
      --bg-blur: 2px;     /* blur amount */
    }

    html, body {
      margin:0; padding:0;
      color:#f2f2f2;
      font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:#0b0b0b; /* fallback */
    }

    body {
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    /* Background image layer */
    body::before {
      content:"";
      position: fixed;
      inset: 0;
      background-image: var(--bg-url);
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      transform: scale(1.02); /* avoids edge gaps on some browsers */
      filter: saturate(1.05) contrast(1.05);
      z-index: -2;
    }

    /* Dark/blur overlay layer for readability */
    body::after {
      content:"";
      position: fixed;
      inset: 0;
      background: linear-gradient(
        180deg,
        rgba(0,0,0,var(--bg-dim)),
        rgba(0,0,0,calc(var(--bg-dim) + 0.08))
      );
      backdrop-filter: blur(var(--bg-blur));
      -webkit-backdrop-filter: blur(var(--bg-blur));
      z-index: -1;
    }

    .wrap { max-width: 980px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .muted { color:#bdbdbd; }

    /* slightly transparent cards look nicer on photo backgrounds */
    .card {
      background: rgba(21,21,21,0.82);
      border: 1px solid rgba(36,36,36,0.9);
      border-radius: 14px;
      padding: 14px;
      margin: 12px 0;
      box-shadow: 0 6px 28px rgba(0,0,0,0.35);
    }

    .row { display:flex; gap:12px; flex-wrap: wrap; align-items:center; }
    label { display:flex; gap:8px; align-items:center; }

    input[type="number"], input[type="password"] {
      width: 140px; padding: 6px 8px;
      border-radius: 10px; border:1px solid #2b2b2b;
      background: rgba(15,15,15,0.9);
      color:#fff;
    }
    input[type="password"] { width: 220px; }

    button {
      padding: 8px 10px; border-radius: 10px;
      border:1px solid #2b2b2b;
      background: rgba(15,15,15,0.9);
      color:#fff; cursor:pointer;
    }
    button:hover { background: rgba(20,20,20,0.95); }

    table { width:100%; border-collapse: collapse; }
    th, td { text-align:left; padding: 10px 8px; border-bottom: 1px solid rgba(36,36,36,0.9); vertical-align: top; }
    th { color:#cfcfcf; font-weight:600; }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .right { text-align:right; }

    a { color:#9dd1ff; text-decoration:none; }
    a:hover { text-decoration:underline; }

    .pill {
      display:inline-block; padding: 2px 8px; border-radius: 999px;
      border:1px solid #2b2b2b; background: rgba(15,15,15,0.9);
      color:#eaeaea; font-size: 12px;
    }
    .ok { border-color:#2e5; color:#bfffd0; }
    .bad { border-color:#e55; color:#ffd0d0; }
    .small { font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Status & timing control</h1>

    <div class="card">
      <div class="row">
        <label>Seconds per poster
          <input id="posterSeconds" type="number" min="1" placeholder="12">
        </label>
        <label>Fade (ms)
          <input id="fadeMs" type="number" min="0" placeholder="900">
        </label>
        <label>Refresh (sec)
          <input id="refreshSeconds" type="number" min="30" placeholder="300">
        </label>
      </div>

      <div class="row" style="margin-top:10px;">
        <label>Update key
          <input id="updateKey" type="password" placeholder="(required)">
        </label>
        <button id="applyBtn">Apply</button>
        <span id="info" class="muted small"></span>
      </div>

      <div class="muted small" style="margin-top:10px;">
        Apply updates the shared config in Drive. All slideshow pages pick it up automatically.
      </div>
    </div>

    <div class="card">
      <div class="muted small" style="margin-bottom:10px;">
        Counts are based on <span class="mono">assets/films.json</span> and <span class="mono">assets/arrangements.json</span>.
        Suggested duration = count × seconds-per-poster.
      </div>

      <table>
        <thead>
          <tr>
            <th>Page</th>
            <th>What it shows</th>
            <th class="right">Count</th>
            <th class="right">Suggested duration</th>
          </tr>
        </thead>
        <tbody id="tbody">
          <tr><td colspan="4" class="muted">Loading…</td></tr>
        </tbody>
      </table>
    </div>

    <div class="card">
      <div class="row" style="gap:10px;">
        <a href="./films-portrait.html" target="_blank">films-portrait</a>
        <a href="./films-landscape.html" target="_blank">films-landscape</a>
        <a href="./arrangements-portrait.html" target="_blank">arrangements-portrait</a>
        <a href="./arrangements-landscape.html" target="_blank">arrangements-landscape</a>
        <a href="./portrait-all.html" target="_blank">portrait-all</a>
        <a href="./landscape-all.html" target="_blank">landscape-all</a>
      </div>
    </div>
  </div>

<script>
(() => {
  const CONFIG_SERVICE_URL = "https://script.google.com/macros/s/AKfycbzfSFnMeg-26QNv802KVleuZWoEPqQE8zU4JwQLO3ikWL-fpYP4SFWTu8Q89jmgXq0YvQ/exec";
  const FILMS_URL = "./assets/films.json";
  const ARR_URL   = "./assets/arrangements.json";

  const DEFAULTS = { posterSeconds: 12, fadeMs: 900, manifestRefreshSeconds: 300 };

  const els = {
    posterSeconds: document.getElementById("posterSeconds"),
    fadeMs: document.getElementById("fadeMs"),
    refreshSeconds: document.getElementById("refreshSeconds"),
    updateKey: document.getElementById("updateKey"),
    applyBtn: document.getElementById("applyBtn"),
    tbody: document.getElementById("tbody"),
    info: document.getElementById("info"),
  };

  const setInfo = (msg) => { els.info.textContent = msg || ""; };

  function pill(text, cls="ok") { return `<span class="pill ${cls}">${text}</span>`; }

  function fmtDuration(seconds) {
    seconds = Math.max(0, Math.round(seconds));
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${m}:${String(s).padStart(2,'0')}`;
  }

  async function fetchJson(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`${r.status} ${r.statusText} for ${url}`);
    return await r.json();
  }

  function safeNumber(x) {
    const n = Number(x);
    return Number.isFinite(n) ? n : null;
  }

  function normalizeCfg(raw) {
    if (!raw) return {};
    if (typeof raw === "string") { try { return JSON.parse(raw); } catch { return {}; } }
    if (raw.data && typeof raw.data === "object") return raw.data;
    if (raw.config && typeof raw.config === "object") return raw.config;
    return raw;
  }

  function isMeaningfulCfg(raw) {
    const cfg = normalizeCfg(raw);
    const refresh = cfg.manifestRefreshSeconds ?? cfg.refreshSeconds;
    return (cfg.posterSeconds != null) || (cfg.fadeMs != null) || (refresh != null);
  }

  // JSONP loader (avoids CORS). Detects "HTML/login page" cases too.
  function loadConfigJSONP(extraParams = {}, timeoutMs = 7000) {
    return new Promise((resolve) => {
      const cbName = "__cfgcb_" + Math.random().toString(16).slice(2);
      let called = false;
      let finished = false;

      window[cbName] = (cfg) => {
        called = true;
        finish(cfg || {});
      };

      const params = new URLSearchParams({
        callback: cbName,
        _: String(Date.now()),
        ...Object.fromEntries(Object.entries(extraParams).filter(([,v]) => v != null && String(v).length > 0))
      });

      const s = document.createElement("script");
      s.src = CONFIG_SERVICE_URL + "?" + params.toString();

      s.onerror = () => {
        setInfo("Config read failed (script error).");
        finish({});
      };

      s.onload = () => {
        setTimeout(() => {
          if (!finished && !called) {
            setInfo("Config endpoint did not call JSONP callback.");
            finish({});
          }
        }, 250);
      };

      document.head.appendChild(s);

      const t = setTimeout(() => {
        if (!finished) {
          setInfo("Config read timed out.");
          finish({});
        }
      }, timeoutMs);

      function cleanup() {
        clearTimeout(t);
        try { delete window[cbName]; } catch {}
        s.remove();
      }

      function finish(val) {
        if (finished) return;
        finished = true;
        cleanup();
        resolve(val);
      }
    });
  }

  function setUiConfig(rawCfg) {
    const cfg = normalizeCfg(rawCfg);
    const refresh = cfg.manifestRefreshSeconds ?? cfg.refreshSeconds;

    // Only touch fields that exist (never snap-back due to empty load)
    if (cfg.posterSeconds != null) els.posterSeconds.value = cfg.posterSeconds;
    if (cfg.fadeMs != null) els.fadeMs.value = cfg.fadeMs;
    if (refresh != null) els.refreshSeconds.value = refresh;
  }

  function readUiConfig() {
    return {
      posterSeconds: safeNumber(els.posterSeconds.value) ?? DEFAULTS.posterSeconds,
      fadeMs: safeNumber(els.fadeMs.value) ?? DEFAULTS.fadeMs,
      manifestRefreshSeconds: safeNumber(els.refreshSeconds.value) ?? DEFAULTS.manifestRefreshSeconds,
    };
  }

  function countField(items, field) {
    return (items || []).map(x => x?.[field]).filter(Boolean).length;
  }

  async function renderCounts() {
    const posterSeconds = safeNumber(els.posterSeconds.value) ?? DEFAULTS.posterSeconds;
    els.tbody.innerHTML = `<tr><td colspan="4" class="muted">Loading…</td></tr>`;

    try {
      const [filmsData, arrData] = await Promise.all([fetchJson(FILMS_URL), fetchJson(ARR_URL)]);
      const films = filmsData.films || [];
      const arrs  = arrData.arrangements || [];

      const filmsPortrait = countField(films, "poster");
      const filmsLandscape= countField(films, "landscape");
      const arrPortrait   = countField(arrs, "poster");
      const arrLandscape  = countField(arrs, "landscape");

      const portraitAll = filmsPortrait + arrPortrait;
      const landscapeAll= filmsLandscape + arrLandscape;

      const rows = [
        { page:"films-portrait.html", desc:"Films portrait (poster)", count: filmsPortrait },
        { page:"films-landscape.html", desc:"Films landscape (subset)", count: filmsLandscape },
        { page:"arrangements-portrait.html", desc:"Arrangements portrait (poster)", count: arrPortrait },
        { page:"arrangements-landscape.html", desc:"Arrangements landscape (subset)", count: arrLandscape },
        { page:"portrait-all.html", desc:"Films then arrangements (portrait)", count: portraitAll },
        { page:"landscape-all.html", desc:"Films then arrangements (landscape subset)", count: landscapeAll }
      ];

      els.tbody.innerHTML = rows.map(r => `
        <tr>
          <td>${pill("ok","ok")} <a href="./${r.page}" target="_blank">${r.page}</a></td>
          <td class="muted">${r.desc}</td>
          <td class="right mono">${r.count}</td>
          <td class="right mono">${fmtDuration(r.count * posterSeconds)}</td>
        </tr>
      `).join("");

      const u1 = filmsData.updated ? `films: ${filmsData.updated}` : `films: (no updated)`;
      const u2 = arrData.updated ? `arr: ${arrData.updated}` : `arr: (no updated)`;
      if (!els.info.textContent || els.info.textContent.startsWith("films:") || els.info.textContent.startsWith("arr:")) {
        els.info.textContent = `${u1} | ${u2}`;
      }
    } catch (e) {
      els.tbody.innerHTML = `<tr><td colspan="4">${pill("ERROR","bad")} <span class="mono">${String(e.message || e)}</span></td></tr>`;
    }
  }

  async function reloadConfig() {
    let cfg = await loadConfigJSONP({});
    if (isMeaningfulCfg(cfg)) {
      setUiConfig(cfg);
      return true;
    }

    const key = (els.updateKey.value || "").trim();
    if (key) {
      const cfg2 = await loadConfigJSONP({ key });
      if (isMeaningfulCfg(cfg2)) {
        setUiConfig(cfg2);
        return true;
      }
    }
    return false;
  }

  async function applyConfig() {
    const key = (els.updateKey.value || "").trim();
    if (!key) { setInfo("Update key is required."); return; }

    const cfg = readUiConfig();
    const body = new URLSearchParams({
      posterSeconds: String(cfg.posterSeconds),
      fadeMs: String(cfg.fadeMs),
      manifestRefreshSeconds: String(cfg.manifestRefreshSeconds),
    }).toString();

    const url = CONFIG_SERVICE_URL + "?key=" + encodeURIComponent(key);

    setInfo("Applying…");

    try {
      await fetch(url, {
        method: "POST",
        mode: "no-cors",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body
      });

      setTimeout(async () => {
        const ok = await reloadConfig();
        await renderCounts();
        setInfo(ok ? "Applied ✓" : "Applied ✓ (saved, but reload returned empty)");
      }, 1200);

    } catch (e) {
      setInfo("Apply failed: " + String(e.message || e));
    }
  }

  els.applyBtn.addEventListener("click", applyConfig);

  // ✅ always clear password on reload/navigation away and never store it
  window.addEventListener("beforeunload", () => { els.updateKey.value = ""; });

  (async () => {
    // show defaults immediately
    els.posterSeconds.value = DEFAULTS.posterSeconds;
    els.fadeMs.value = DEFAULTS.fadeMs;
    els.refreshSeconds.value = DEFAULTS.manifestRefreshSeconds;

    // ✅ clear password every page load
    els.updateKey.value = "";

    await reloadConfig();
    await renderCounts();
  })();
})();
</script>
</body>
</html>
