<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arrangements â€“ Landscape</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    .stage { position:relative; width:100%; height:100%; }
    .layer { position:absolute; inset:0; width:100%; height:100%; object-fit:contain; opacity:0; transition: opacity 900ms ease-in-out; will-change: opacity; }
    .layer.show { opacity:1; }
    #empty { position:fixed; inset:0; display:none; align-items:center; justify-content:center; color:#fff; background:#000; text-align:center; padding:40px;
      font: 26px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  </style>
</head>
<body>
  <div id="empty">No arrangement landscape posters available.</div>
  <div class="stage">
    <img id="a" class="layer show" alt="">
    <img id="b" class="layer" alt="">
  </div>

<script>
(async () => {
  const CONFIG_SERVICE_URL = "https://script.google.com/macros/s/AKfycbzfSFnMeg-26QNv802KVleuZWoEPqQE8zU4JwQLO3ikWL-fpYP4SFWTu8Q89jmgXq0YvQ/exec";
  const MANIFEST_URL = "./assets/arrangements.json";
  const FIELD = "landscape";

  let posterSeconds = 12;
  let fadeMs = 900;
  let refreshSeconds = 300;

  let urls = [];
  let idx = 0;
  let frontIsA = true;
  let version = "";

  const emptyEl = document.getElementById("empty");
  const A = document.getElementById("a");
  const B = document.getElementById("b");

  function numParam(name, fallback) {
    const v = new URLSearchParams(location.search).get(name);
    const n = Number(v);
    return Number.isFinite(n) && n > 0 ? n : fallback;
  }

  async function fetchJson(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  }

  function loadConfigJSONP(timeoutMs = 4000) {
    return new Promise((resolve) => {
      const cbName = "__cfgcb_" + Math.random().toString(16).slice(2);
      let done = false;

      window[cbName] = (cfg) => {
        done = true;
        cleanup();
        resolve(cfg || {});
      };

      const s = document.createElement("script");
      s.src = CONFIG_SERVICE_URL + "?callback=" + cbName + "&_=" + Date.now();
      s.onerror = () => { cleanup(); resolve({}); };
      document.head.appendChild(s);

      const t = setTimeout(() => { if (!done) { cleanup(); resolve({}); } }, timeoutMs);

      function cleanup() {
        clearTimeout(t);
        try { delete window[cbName]; } catch {}
        s.remove();
      }
    });
  }

  async function load() {
    const [cfg, data] = await Promise.all([loadConfigJSONP(), fetchJson(MANIFEST_URL)]);

    posterSeconds  = numParam("p", cfg.posterSeconds ?? 12);
    fadeMs         = numParam("fade", cfg.fadeMs ?? 900);
    refreshSeconds = numParam("r", cfg.manifestRefreshSeconds ?? 300);

    A.style.transitionDuration = fadeMs + "ms";
    B.style.transitionDuration = fadeMs + "ms";

    version = data.updated ? ("?v=" + encodeURIComponent(data.updated)) : "";
    urls = (data.arrangements || []).map(x => x?.[FIELD]).filter(Boolean);
    idx = 0;
    emptyEl.style.display = urls.length ? "none" : "flex";
  }

  async function preload(url) {
    await new Promise(resolve => {
      const img = new Image();
      img.onload = resolve;
      img.onerror = resolve;
      img.src = url + version;
    });
  }

  function swapTo(url) {
    const front = frontIsA ? A : B;
    const back  = frontIsA ? B : A;
    back.src = url + version;
    back.classList.add("show");
    front.classList.remove("show");
    frontIsA = !frontIsA;
  }

  async function tick() {
    if (!urls.length) { setTimeout(tick, 2000); return; }
    const url = urls[idx % urls.length];
    idx += 1;
    await preload(url);
    swapTo(url);
    setTimeout(tick, posterSeconds * 1000);
  }

  await load();
  tick();
  setInterval(() => load().catch(()=>{}), refreshSeconds * 1000);
})();
</script>
</body>
</html>
