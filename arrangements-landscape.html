<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arrangements â€“ Landscape</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    .stage { position:relative; width:100%; height:100%; }
    .layer {
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:contain;
      opacity:0;
      transition: opacity 900ms ease-in-out;
      will-change: opacity;
    }
    .layer.show { opacity:1; }
    #empty {
      position:fixed; inset:0; display:none;
      align-items:center; justify-content:center;
      color:#fff; background:#000; text-align:center; padding:40px;
      font: 26px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
  </style>
</head>
<body>
  <div id="empty">No arrangement landscape posters available.</div>
  <div class="stage">
    <img id="a" class="layer show" alt="">
    <img id="b" class="layer" alt="">
  </div>

<script>
(async () => {
  const CONFIG_URL = "./assets/display-config.json";
  const MANIFEST_URL = "./assets/arrangements.json";
  const FIELD = "landscape";

  let posterSeconds = 12;
  let fadeMs = 900;
  let refreshSeconds = 300;

  let urls = [];
  let idx = 0;
  let frontIsA = true;
  let version = "";

  const emptyEl = document.getElementById("empty");
  const A = document.getElementById("a");
  const B = document.getElementById("b");

  function numParam(name, fallback) {
    const v = new URLSearchParams(location.search).get(name);
    const n = Number(v);
    return Number.isFinite(n) && n > 0 ? n : fallback;
  }

  async function fetchJson(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  }

  async function loadConfig() {
    try { return await fetchJson(CONFIG_URL); }
    catch { return {}; }
  }

  async function load() {
    const [cfg, data] = await Promise.all([loadConfig(), fetchJson(MANIFEST_URL)]);

    posterSeconds  = numParam("p", cfg.posterSeconds ?? 12);
    fadeMs         = numParam("fade", cfg.fadeMs ?? 900);
    refreshSeconds = numParam("r", cfg.manifestRefreshSeconds ?? 300);

    A.style.transitionDuration = fadeMs + "ms";
    B.style.transitionDuration = fadeMs + "ms";

    version = data.updated ? ("?v=" + encodeURIComponent(data.updated)) : "";

    urls = (data.arrangements || []).map(x => x?.[FIELD]).filter(Boolean);
    idx = 0;

    emptyEl.style.display = urls.length ? "none" : "flex";
  }

  async function preload(url) {
    await new Promise(resolve => {
      const img = new Image();
      img.onload = resolve;
      img.onerror = resolve;
      img.src = url + version;
    });
  }

  function swapTo(url) {
    const front = frontIsA ? A : B;
    const back  = frontIsA ? B : A;

    back.src = url + version;
    back.classList.add("show");
    front.classList.remove("show");
    frontIsA = !frontIsA;
  }

  async function tick() {
    if (!urls.length) { setTimeout(tick, 2000); return; }
    const url = urls[idx % urls.length];
    idx += 1;
    await preload(url);
    swapTo(url);
    setTimeout(tick, posterSeconds * 1000);
  }

  await load();
  tick();
  setInterval(() => load().catch(()=>{}), refreshSeconds * 1000);
})();
</script>
</body>
</html>
